# distutils: language = c++
# cython: embedsignature = True

from libc.stdint cimport (uint8_t, uint16_t, uint32_t, uint64_t, int8_t,
                          int16_t, int32_t, int64_t)
from cythrust.thrust.device_vector cimport device_vector
from cythrust.thrust.reduce cimport reduce_by_key
from cythrust.thrust.iterator.transform_iterator cimport make_transform_iterator
from cythrust.thrust.iterator.zip_iterator cimport make_zip_iterator
from cythrust.thrust.tuple cimport make_tuple2
from cythrust.thrust.functional cimport equal_to, duplicate, minmax_tuple

{% for ctype, dtype in DEVICE_VECTOR_TYPES -%}
from cythrust.device_vector cimport DeviceVector{{ dtype[3:].title() }}
{% endfor %}


{% for ctype, dtype in DEVICE_VECTOR_TYPES %}
cpdef minmax_{{ dtype[3:] }}_by_key(DeviceVectorInt32 keys,
                                DeviceVector{{ dtype[3:].title() }} values,
                                DeviceVectorInt32 reduced_keys,
                                DeviceVector{{ dtype[3:].title() }} min_values,
                                DeviceVector{{ dtype[3:].title() }} max_values):
    cdef duplicate[{{ ctype }}] duplicate_f
    cdef minmax_tuple[{{ ctype }}] minmax_f
    cdef equal_to[int32_t] reduce_compare  # Functor to compare reduction keys.

    # result_type operator() (T1 j_is_sync, T2 delay_ij, T3 t_a_j) {
    cdef int32_t count = (<device_vector[int32_t].iterator>(reduce_by_key(
        keys._vector.begin(), keys._vector.end(),
        make_transform_iterator(values._vector.begin(), duplicate_f),
        reduced_keys._vector.begin(),
        make_zip_iterator(
            make_tuple2(min_values._vector.begin(),
                        max_values._vector.begin())),
        reduce_compare, minmax_f).first) - reduced_keys._vector.begin())
    return count
{% endfor %}
